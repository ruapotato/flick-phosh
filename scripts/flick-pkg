#!/usr/bin/env python3
"""
Flick Package Manager

Commands:
    list        - List available packages (remote + local)
    installed   - List installed apps
    install     - Install a package
    uninstall   - Remove an installed app
    search      - Search packages
    update      - Update package cache from remote
    feedback    - Submit feedback for an app (with optional logs)
    logs        - View app logs
    subscribe   - Subscribe to app updates
    unsubscribe - Unsubscribe from app updates
"""

import os
import sys
import json
import shutil
import argparse
import tempfile
import zipfile
import tarfile
import glob
import time
from pathlib import Path
from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError
from datetime import datetime

# Configuration
DEFAULT_REPO = "https://255.one"
API_BASE = "/api"
DEVICE_CONFIG_PATH = "/etc/flick/device.conf"

def load_device_config():
    """Load device configuration from /etc/flick/device.conf."""
    config = {}
    if os.path.exists(DEVICE_CONFIG_PATH):
        try:
            with open(DEVICE_CONFIG_PATH) as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        # Remove quotes from value
                        value = value.strip().strip('"').strip("'")
                        config[key.strip()] = value
        except Exception as e:
            print(f"Warning: Could not load device config: {e}")
    return config

def get_home():
    """Get the real user's home directory."""
    # First check environment variables (set by systemd services)
    for env_var in ['FLICK_HOME', 'FLICK_USER', 'SUDO_USER']:
        if env_var == 'FLICK_HOME':
            home = os.environ.get(env_var, '')
            if home and os.path.exists(home):
                return Path(home)
        else:
            user = os.environ.get(env_var, '')
            if user and user != 'root':
                home = f'/home/{user}'
                if os.path.exists(home):
                    return Path(home)

    # Check device config
    config = load_device_config()
    if config.get('DEVICE_HOME') and os.path.exists(config['DEVICE_HOME']):
        return Path(config['DEVICE_HOME'])
    if config.get('DEVICE_USER'):
        home = f"/home/{config['DEVICE_USER']}"
        if os.path.exists(home):
            return Path(home)

    # Fallbacks for known systems
    if os.path.exists('/home/furios'):
        return Path('/home/furios')
    if os.path.exists('/home/droidian'):
        return Path('/home/droidian')

    return Path(os.environ.get('HOME', '/root'))

HOME = get_home()
FLICK_DIR = HOME / 'Flick'
APPS_DIR = FLICK_DIR / 'apps'
PACKAGES_DIR = FLICK_DIR / 'store' / 'packages'
SIGNAL_FILE = Path('/tmp/flick_rescan_apps')
STATE_DIR = HOME / '.local' / 'state' / 'flick'
CACHE_DIR = STATE_DIR / 'pkg_cache'
INSTALLED_FILE = STATE_DIR / 'store_installed.json'
REPOS_FILE = STATE_DIR / 'repositories.json'
SUBSCRIPTIONS_FILE = STATE_DIR / 'subscriptions.json'

# Logging configuration
DATA_DIR = HOME / '.local' / 'share' / 'flick'
LOGS_DIR = DATA_DIR / 'logs'
LOG_MAX_SIZE = 1024 * 1024  # 1MB
LOG_MAX_FILES = 5  # Keep last 5 log files

def api_get(endpoint, repo=DEFAULT_REPO):
    """Make a GET request to the API."""
    url = f"{repo}{API_BASE}{endpoint}"
    try:
        req = Request(url, headers={'User-Agent': 'flick-pkg/1.0'})
        with urlopen(req, timeout=30) as response:
            return json.loads(response.read().decode())
    except HTTPError as e:
        print(f"HTTP Error {e.code}: {e.reason}")
        return None
    except URLError as e:
        print(f"Connection error: {e.reason}")
        return None
    except Exception as e:
        print(f"Error: {e}")
        return None

def download_file(url, dest_path):
    """Download a file from URL."""
    try:
        req = Request(url, headers={'User-Agent': 'flick-pkg/1.0'})
        with urlopen(req, timeout=120) as response:
            with open(dest_path, 'wb') as f:
                shutil.copyfileobj(response, f)
        return True
    except Exception as e:
        print(f"Download error: {e}")
        return False

def api_post(endpoint, data, repo=DEFAULT_REPO):
    """Make a POST request to the API."""
    url = f"{repo}{API_BASE}{endpoint}"
    try:
        body = json.dumps(data).encode('utf-8')
        req = Request(url, data=body, headers={
            'User-Agent': 'flick-pkg/1.0',
            'Content-Type': 'application/json'
        })
        with urlopen(req, timeout=30) as response:
            return json.loads(response.read().decode())
    except HTTPError as e:
        try:
            error_body = json.loads(e.read().decode())
            return {'error': error_body.get('error', f'HTTP {e.code}')}
        except:
            return {'error': f'HTTP {e.code}: {e.reason}'}
    except URLError as e:
        return {'error': f'Connection error: {e.reason}'}
    except Exception as e:
        return {'error': str(e)}

# ============================================================================
# LOGGING INFRASTRUCTURE
# ============================================================================

def get_log_dir(app_id):
    """Get the log directory for an app."""
    log_dir = LOGS_DIR / app_id
    log_dir.mkdir(parents=True, exist_ok=True)
    return log_dir

def get_log_file(app_id):
    """Get the current log file path for an app."""
    return get_log_dir(app_id) / 'app.log'

def rotate_logs(app_id):
    """Rotate log files when they exceed max size."""
    log_file = get_log_file(app_id)
    if not log_file.exists():
        return

    if log_file.stat().st_size < LOG_MAX_SIZE:
        return

    log_dir = get_log_dir(app_id)

    # Delete oldest if we have max files
    existing = sorted(log_dir.glob('app.log.*'), key=lambda p: p.stat().st_mtime)
    while len(existing) >= LOG_MAX_FILES - 1:
        oldest = existing.pop(0)
        oldest.unlink()

    # Rotate current log
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    rotated = log_dir / f'app.log.{timestamp}'
    log_file.rename(rotated)

def write_log(app_id, message, level='INFO'):
    """Write a log entry for an app."""
    rotate_logs(app_id)
    log_file = get_log_file(app_id)
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    entry = f"[{timestamp}] [{level}] {message}\n"
    with open(log_file, 'a') as f:
        f.write(entry)

def read_logs(app_id, lines=100, include_rotated=False):
    """Read recent log entries for an app."""
    log_dir = get_log_dir(app_id)
    log_file = get_log_file(app_id)

    all_lines = []

    if include_rotated:
        # Read rotated logs (oldest first)
        for rotated in sorted(log_dir.glob('app.log.*')):
            try:
                with open(rotated) as f:
                    all_lines.extend(f.readlines())
            except:
                pass

    # Read current log
    if log_file.exists():
        try:
            with open(log_file) as f:
                all_lines.extend(f.readlines())
        except:
            pass

    # Return last N lines
    return all_lines[-lines:] if lines else all_lines

def get_all_logs_for_app(app_id):
    """Get all log files for an app (for feedback attachment)."""
    log_dir = get_log_dir(app_id)
    if not log_dir.exists():
        return []

    logs = []
    for log_path in sorted(log_dir.glob('app.log*')):
        try:
            with open(log_path) as f:
                content = f.read()
            logs.append({
                'filename': log_path.name,
                'content': content,
                'size': log_path.stat().st_size,
                'modified': log_path.stat().st_mtime
            })
        except:
            pass
    return logs

# ============================================================================
# SUBSCRIPTIONS
# ============================================================================

def load_subscriptions():
    """Load app subscriptions."""
    if SUBSCRIPTIONS_FILE.exists():
        try:
            with open(SUBSCRIPTIONS_FILE) as f:
                return json.load(f)
        except:
            pass
    return {'apps': [], 'last_check': 0}

def save_subscriptions(data):
    """Save app subscriptions."""
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    with open(SUBSCRIPTIONS_FILE, 'w') as f:
        json.dump(data, f, indent=2)

def get_repos():
    """Get list of repositories."""
    if REPOS_FILE.exists():
        try:
            with open(REPOS_FILE) as f:
                data = json.load(f)
                return data.get('repositories', [DEFAULT_REPO])
        except:
            pass
    return [DEFAULT_REPO]

def load_manifest(path):
    """Load a manifest.json file."""
    manifest_path = path / 'manifest.json'
    if manifest_path.exists():
        try:
            with open(manifest_path) as f:
                return json.load(f)
        except:
            pass
    return None

def get_local_app_info(path):
    """Get app info from a local directory."""
    manifest = load_manifest(path)
    app_id = path.name
    if manifest:
        return {
            'id': app_id,
            'name': manifest.get('name', app_id.title()),
            'version': manifest.get('version', '1.0.0'),
            'description': manifest.get('description', ''),
            'source': 'local',
        }
    if (path / 'main.qml').exists() or (path / f'run_{app_id}.sh').exists():
        return {
            'id': app_id,
            'name': app_id.title(),
            'version': '1.0.0',
            'description': '',
            'source': 'local',
        }
    return None

def signal_rescan():
    """Signal phosh to rescan apps by updating desktop database."""
    SIGNAL_FILE.touch()
    # Update desktop database for phosh
    os.system('update-desktop-database ~/.local/share/applications 2>/dev/null')
    print("  (Phosh will detect new apps automatically)")


def create_desktop_file_for_app(app_id, app_dir, manifest=None):
    """Create a .desktop file for phosh integration."""
    if manifest is None:
        manifest = load_manifest(app_dir) or {}

    name = manifest.get('name', app_id.replace('-', ' ').replace('_', ' ').title())

    # Determine exec command
    if (app_dir / f'run_{app_id}.sh').exists():
        exec_cmd = f'sh {app_dir}/run_{app_id}.sh'
    elif (app_dir / 'app/main.qml').exists():
        exec_cmd = f'qmlscene {app_dir}/app/main.qml'
    elif (app_dir / 'main.qml').exists():
        exec_cmd = f'qmlscene {app_dir}/main.qml'
    else:
        return None

    # Icon - use app_id, the icon manager will handle installation
    icon_name = f'flick-{app_id}'

    categories = manifest.get('categories', 'Utility')

    content = f"""[Desktop Entry]
Type=Application
Name={name}
Exec={exec_cmd}
Icon={icon_name}
Categories={categories};
Terminal=false
StartupNotify=true
X-Flick-App=true
"""

    desktop_dir = HOME / '.local/share/applications'
    desktop_dir.mkdir(parents=True, exist_ok=True)
    dest = desktop_dir / f'flick-{app_id}.desktop'

    with open(dest, 'w') as f:
        f.write(content)

    dest.chmod(0o755)
    return dest


def remove_desktop_file_for_app(app_id):
    """Remove the .desktop file for an app."""
    desktop_file = HOME / '.local/share/applications' / f'flick-{app_id}.desktop'
    if desktop_file.exists():
        desktop_file.unlink()
        return True
    return False

def load_store_installed():
    """Load the Store's installed apps list."""
    if INSTALLED_FILE.exists():
        try:
            with open(INSTALLED_FILE) as f:
                return json.load(f).get('apps', [])
        except:
            pass
    return []

def save_store_installed(apps):
    """Save the Store's installed apps list."""
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    with open(INSTALLED_FILE, 'w') as f:
        json.dump({'apps': apps}, f, indent=2)

def add_to_store_installed(info):
    """Add an app to the Store's installed list."""
    import time
    apps = load_store_installed()
    apps = [a for a in apps if a.get('id') != info['id']]
    apps.append({
        'id': info['id'],
        'name': info['name'],
        'icon': info.get('icon', 'app'),
        'version': info['version'],
        'installedAt': int(time.time() * 1000)
    })
    save_store_installed(apps)

def remove_from_store_installed(app_id):
    """Remove an app from the Store's installed list."""
    apps = load_store_installed()
    apps = [a for a in apps if a.get('id') != app_id]
    save_store_installed(apps)

def extract_flick_package(flick_path, dest_dir):
    """Extract a .flick package (zip or tar.gz)."""
    try:
        # Try as zip first
        if zipfile.is_zipfile(flick_path):
            with zipfile.ZipFile(flick_path, 'r') as zf:
                zf.extractall(dest_dir)
            return True
    except:
        pass

    try:
        # Try as tar.gz
        with tarfile.open(flick_path, 'r:*') as tf:
            tf.extractall(dest_dir)
        return True
    except:
        pass

    return False

def cmd_list(args):
    """List available packages from remote and local."""
    print("\nFetching packages from remote repositories...")

    all_packages = []

    # Fetch from remote repos
    for repo in get_repos():
        print(f"  Checking {repo}...")
        data = api_get("/apps?per_page=100", repo)
        if data and 'apps' in data:
            for app in data['apps']:
                all_packages.append({
                    'id': app.get('slug', app.get('id', '')),
                    'name': app.get('name', ''),
                    'version': app.get('version', '1.0.0'),
                    'description': app.get('description', ''),
                    'downloads': app.get('download_count', 0),
                    'source': repo,
                })

    # Add local packages
    if PACKAGES_DIR.exists():
        for pkg_dir in PACKAGES_DIR.iterdir():
            if pkg_dir.is_dir() and not pkg_dir.name.startswith('.'):
                info = get_local_app_info(pkg_dir)
                if info:
                    # Don't duplicate if already in remote
                    if not any(p['id'] == info['id'] for p in all_packages):
                        all_packages.append(info)

    if not all_packages:
        print("\nNo packages available")
        return 0

    print(f"\nAvailable packages ({len(all_packages)}):\n")
    for pkg in sorted(all_packages, key=lambda x: x['name'].lower()):
        installed = (APPS_DIR / pkg['id']).exists()
        status = "[installed]" if installed else ""
        source = "(local)" if pkg.get('source') == 'local' else ""
        print(f"  {pkg['id']:20} {pkg['name'][:25]:25} {status} {source}")
        if pkg.get('description'):
            desc = pkg['description'][:50] + '...' if len(pkg.get('description', '')) > 50 else pkg.get('description', '')
            print(f"                       {desc}")
    print()
    return 0

def cmd_installed(args):
    """List installed apps."""
    skip = {'lockscreen', 'shared', 'welcome', 'store'}
    apps = []

    if APPS_DIR.exists():
        for app_dir in sorted(APPS_DIR.iterdir()):
            if app_dir.is_dir() and not app_dir.name.startswith('.'):
                if app_dir.name in skip:
                    continue
                info = get_local_app_info(app_dir)
                if info:
                    apps.append(info)

    if not apps:
        print("No apps installed")
        return 0

    print(f"\nInstalled apps ({len(apps)}):\n")
    for info in apps:
        print(f"  {info['id']:20} {info['name']:25} v{info['version']}")
    print()
    return 0

def cmd_install(args):
    """Install a package from remote or local."""
    pkg_id = args.package
    dest_dir = APPS_DIR / pkg_id

    if dest_dir.exists():
        print(f"Already installed: {pkg_id}")
        return 1

    # Check local packages first
    local_pkg = PACKAGES_DIR / pkg_id
    if local_pkg.exists():
        info = get_local_app_info(local_pkg)
        if info:
            print(f"Installing {info['name']} ({pkg_id}) from local...")
            try:
                shutil.copytree(local_pkg, dest_dir)
                print(f"  Copied to {dest_dir}")
                add_to_store_installed(info)
                # Create .desktop file for phosh
                create_desktop_file_for_app(pkg_id, dest_dir)
                print(f"  Created .desktop file for phosh")
                signal_rescan()
                print(f"Successfully installed: {info['name']}")
                return 0
            except Exception as e:
                print(f"Installation failed: {e}")
                return 1

    # Try remote repos
    print(f"Searching remote repositories for {pkg_id}...")
    for repo in get_repos():
        # Get app info
        data = api_get(f"/apps/{pkg_id}", repo)
        if not data or 'app' not in data:
            continue

        app = data['app']
        print(f"Found {app['name']} v{app.get('version', '1.0.0')} on {repo}")

        # Download package
        download_url = f"{repo}{API_BASE}/apps/{pkg_id}/download"
        print(f"  Downloading...")

        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        flick_path = CACHE_DIR / f"{pkg_id}.flick"

        if not download_file(download_url, flick_path):
            print(f"  Failed to download from {repo}")
            continue

        print(f"  Extracting...")

        # Extract to temp dir first
        with tempfile.TemporaryDirectory() as tmpdir:
            tmppath = Path(tmpdir)
            if not extract_flick_package(flick_path, tmppath):
                print(f"  Failed to extract package")
                continue

            # Find the app directory (might be nested)
            app_content = None
            for item in tmppath.iterdir():
                if item.is_dir():
                    if (item / 'main.qml').exists() or (item / 'manifest.json').exists():
                        app_content = item
                        break
            if not app_content:
                # Check if files are at root level
                if (tmppath / 'main.qml').exists() or (tmppath / 'manifest.json').exists():
                    app_content = tmppath

            if not app_content:
                print(f"  Invalid package structure")
                continue

            # Move to apps directory
            shutil.copytree(app_content, dest_dir)

        # Clean up cache
        flick_path.unlink(missing_ok=True)

        info = {
            'id': pkg_id,
            'name': app['name'],
            'version': app.get('version', '1.0.0'),
            'icon': app.get('icon', 'app'),
        }
        add_to_store_installed(info)
        # Create .desktop file for phosh
        create_desktop_file_for_app(pkg_id, dest_dir)
        print(f"  Created .desktop file for phosh")
        signal_rescan()
        print(f"Successfully installed: {app['name']}")
        return 0

    print(f"Package not found: {pkg_id}")
    return 1

def cmd_uninstall(args):
    """Uninstall an app."""
    app_id = args.package
    app_dir = APPS_DIR / app_id

    protected = {'settings', 'store', 'browser',
                 'camera', 'gallery', 'files', 'terminal', 'calculator', 'clock',
                 'calendar', 'notes', 'weather', 'maps'}

    if app_id in protected:
        print(f"Cannot uninstall core app: {app_id}")
        return 1

    if not app_dir.exists():
        print(f"App not installed: {app_id}")
        return 1

    info = get_local_app_info(app_dir)
    name = info['name'] if info else app_id

    print(f"Uninstalling {name} ({app_id})...")
    try:
        shutil.rmtree(app_dir)
        print(f"  Removed {app_dir}")
        remove_from_store_installed(app_id)
        # Remove .desktop file from phosh
        remove_desktop_file_for_app(app_id)
        print(f"  Removed .desktop file from phosh")
        signal_rescan()
        print(f"Successfully uninstalled: {name}")
        return 0
    except Exception as e:
        print(f"Uninstall failed: {e}")
        return 1

def cmd_search(args):
    """Search packages."""
    query = args.query.lower()
    results = []

    # Search remote
    for repo in get_repos():
        data = api_get(f"/apps/search?q={query}", repo)
        if data and 'apps' in data:
            for app in data['apps']:
                results.append({
                    'id': app.get('slug', app.get('id', '')),
                    'name': app.get('name', ''),
                    'description': app.get('description', ''),
                    'source': repo,
                })

    # Search local
    if PACKAGES_DIR.exists():
        for pkg_dir in PACKAGES_DIR.iterdir():
            if pkg_dir.is_dir():
                info = get_local_app_info(pkg_dir)
                if info:
                    searchable = f"{info['id']} {info['name']} {info.get('description', '')}".lower()
                    if query in searchable:
                        if not any(r['id'] == info['id'] for r in results):
                            info['source'] = 'local'
                            results.append(info)

    if not results:
        print(f"No packages matching: {query}")
        return 0

    print(f"\nSearch results for '{query}' ({len(results)}):\n")
    for pkg in results:
        installed = (APPS_DIR / pkg['id']).exists()
        status = "[installed]" if installed else ""
        print(f"  {pkg['id']:20} {pkg['name'][:25]:25} {status}")
    print()
    return 0

def cmd_info(args):
    """Show package info."""
    pkg_id = args.package

    # Check installed first
    app_dir = APPS_DIR / pkg_id
    if app_dir.exists():
        info = get_local_app_info(app_dir)
        manifest = load_manifest(app_dir)
        if info:
            print(f"\n{info['name']}")
            print("=" * len(info['name']))
            print(f"ID:          {info['id']}")
            print(f"Version:     {info['version']}")
            print(f"Status:      Installed")
            if manifest and manifest.get('description'):
                print(f"Description: {manifest['description']}")
            print()
            return 0

    # Check remote
    for repo in get_repos():
        data = api_get(f"/apps/{pkg_id}", repo)
        if data and 'app' in data:
            app = data['app']
            print(f"\n{app['name']}")
            print("=" * len(app['name']))
            print(f"ID:          {app.get('slug', pkg_id)}")
            print(f"Version:     {app.get('version', '1.0.0')}")
            print(f"Status:      Not installed")
            print(f"Downloads:   {app.get('download_count', 0)}")
            print(f"Category:    {app.get('category', 'Unknown')}")
            if app.get('description'):
                print(f"Description: {app['description']}")
            print(f"Source:      {repo}")
            print()
            return 0

    # Check local packages
    local_pkg = PACKAGES_DIR / pkg_id
    if local_pkg.exists():
        info = get_local_app_info(local_pkg)
        if info:
            print(f"\n{info['name']}")
            print("=" * len(info['name']))
            print(f"ID:          {info['id']}")
            print(f"Version:     {info['version']}")
            print(f"Status:      Not installed (local package)")
            print()
            return 0

    print(f"Package not found: {pkg_id}")
    return 1

def cmd_update(args):
    """Update package cache from remote."""
    print("Updating package lists...")
    for repo in get_repos():
        print(f"  Fetching from {repo}...")
        data = api_get("/apps?per_page=100", repo)
        if data:
            count = len(data.get('apps', []))
            print(f"    Found {count} packages")
        else:
            print(f"    Failed to connect")
    print("Done.")
    return 0

def cmd_feedback(args):
    """Submit feedback for an app."""
    app_id = args.app
    feedback_type = args.type or 'bug'
    title = args.title
    content = args.message

    if not title:
        title = f"Feedback: {app_id}"

    if not content:
        print("Error: --message is required")
        return 1

    print(f"\nSubmitting {feedback_type} report for {app_id}...")

    # Build feedback data
    data = {
        'type': feedback_type,
        'title': title,
        'content': content,
        'priority': args.priority or 'medium'
    }

    # Attach logs if requested
    if args.attach_logs:
        logs = get_all_logs_for_app(app_id)
        if logs:
            print(f"  Attaching {len(logs)} log file(s)...")
            # Combine logs into content
            log_text = "\n\n=== ATTACHED LOGS ===\n"
            for log in logs:
                log_text += f"\n--- {log['filename']} ---\n"
                # Limit log content to last 500 lines
                lines = log['content'].split('\n')[-500:]
                log_text += '\n'.join(lines)
            data['content'] = content + log_text
        else:
            print("  No logs found for this app")

    # Submit to API
    result = api_post(f"/feedback/app/{app_id}", data)

    if result and 'error' not in result:
        print(f"  Feedback submitted successfully!")
        if 'feedback' in result:
            print(f"  ID: {result['feedback'].get('id', 'N/A')}")
        return 0
    else:
        error = result.get('error', 'Unknown error') if result else 'No response'
        print(f"  Error: {error}")
        return 1

def cmd_logs(args):
    """View logs for an app."""
    app_id = args.app
    log_dir = LOGS_DIR / app_id

    if not log_dir.exists():
        print(f"No logs found for: {app_id}")
        return 0

    if args.clear:
        # Clear all logs for this app
        shutil.rmtree(log_dir)
        print(f"Cleared logs for: {app_id}")
        return 0

    if args.list:
        # List log files
        print(f"\nLog files for {app_id}:\n")
        for log_path in sorted(log_dir.glob('app.log*')):
            size = log_path.stat().st_size
            mtime = datetime.fromtimestamp(log_path.stat().st_mtime)
            size_str = f"{size/1024:.1f}KB" if size > 1024 else f"{size}B"
            print(f"  {log_path.name:25} {size_str:>10}  {mtime.strftime('%Y-%m-%d %H:%M')}")
        return 0

    # Show recent logs
    lines = read_logs(app_id, lines=args.lines or 50, include_rotated=args.all)

    if not lines:
        print(f"No log entries for: {app_id}")
        return 0

    print(f"\n=== Logs for {app_id} (last {len(lines)} lines) ===\n")
    for line in lines:
        print(line.rstrip())
    print()
    return 0

def cmd_subscribe(args):
    """Subscribe to app updates."""
    app_id = args.app

    subs = load_subscriptions()
    if app_id in subs['apps']:
        print(f"Already subscribed to: {app_id}")
        return 0

    # Verify app exists
    data = api_get(f"/apps/{app_id}")
    if not data or 'app' not in data:
        print(f"App not found: {app_id}")
        return 1

    app = data['app']
    subs['apps'].append(app_id)
    save_subscriptions(subs)

    print(f"Subscribed to: {app['name']} ({app_id})")
    print("  You'll receive notifications when new versions are released.")
    return 0

def cmd_unsubscribe(args):
    """Unsubscribe from app updates."""
    app_id = args.app

    subs = load_subscriptions()
    if app_id not in subs['apps']:
        print(f"Not subscribed to: {app_id}")
        return 0

    subs['apps'].remove(app_id)
    save_subscriptions(subs)

    print(f"Unsubscribed from: {app_id}")
    return 0

def cmd_subscriptions(args):
    """List subscribed apps."""
    subs = load_subscriptions()

    if not subs['apps']:
        print("No subscriptions")
        return 0

    print(f"\nSubscribed apps ({len(subs['apps'])}):\n")
    for app_id in sorted(subs['apps']):
        # Get app info
        data = api_get(f"/apps/{app_id}")
        if data and 'app' in data:
            app = data['app']
            print(f"  {app_id:20} {app['name']:25} v{app.get('version', '?')}")
        else:
            print(f"  {app_id:20} (unable to fetch info)")
    print()
    return 0

def cmd_check_updates(args):
    """Check for updates to subscribed apps."""
    subs = load_subscriptions()

    if not subs['apps']:
        print("No subscriptions - nothing to check")
        return 0

    print("Checking for updates...")
    updates = []

    for app_id in subs['apps']:
        # Get remote version
        data = api_get(f"/apps/{app_id}")
        if not data or 'app' not in data:
            continue

        remote_app = data['app']
        remote_version = remote_app.get('version', '0')

        # Get installed version
        app_dir = APPS_DIR / app_id
        if not app_dir.exists():
            continue

        local_info = get_local_app_info(app_dir)
        if not local_info:
            continue

        local_version = local_info.get('version', '0')

        if remote_version != local_version:
            updates.append({
                'id': app_id,
                'name': remote_app['name'],
                'local': local_version,
                'remote': remote_version
            })

    subs['last_check'] = int(time.time())
    save_subscriptions(subs)

    if not updates:
        print("  All subscribed apps are up to date!")
        return 0

    print(f"\n{len(updates)} update(s) available:\n")
    for u in updates:
        print(f"  {u['id']:20} {u['name']:20} {u['local']} -> {u['remote']}")
    print("\nRun 'flick-pkg install <app>' to update")
    return 0

def main():
    parser = argparse.ArgumentParser(
        description='Flick Package Manager',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Default repository: {DEFAULT_REPO}

Examples:
  flick-pkg list                          List all available packages
  flick-pkg search game                   Search for packages
  flick-pkg install distract              Install a package
  flick-pkg uninstall distract            Remove an app
  flick-pkg info distract                 Show package details
  flick-pkg update                        Refresh package lists
  flick-pkg feedback distract -m "bug"    Submit feedback
  flick-pkg feedback distract --attach-logs -m "crash"
  flick-pkg logs distract                 View app logs
  flick-pkg subscribe distract            Subscribe to updates
  flick-pkg subscriptions                 List subscriptions
  flick-pkg check-updates                 Check for updates
"""
    )

    subparsers = parser.add_subparsers(dest='command', help='Command')

    subparsers.add_parser('list', help='List available packages').set_defaults(func=cmd_list)
    subparsers.add_parser('installed', help='List installed apps').set_defaults(func=cmd_installed)
    subparsers.add_parser('update', help='Update package cache').set_defaults(func=cmd_update)

    p = subparsers.add_parser('install', help='Install a package')
    p.add_argument('package', help='Package ID')
    p.set_defaults(func=cmd_install)

    p = subparsers.add_parser('uninstall', help='Uninstall an app')
    p.add_argument('package', help='App ID')
    p.set_defaults(func=cmd_uninstall)

    p = subparsers.add_parser('search', help='Search packages')
    p.add_argument('query', help='Search query')
    p.set_defaults(func=cmd_search)

    p = subparsers.add_parser('info', help='Show package info')
    p.add_argument('package', help='Package ID')
    p.set_defaults(func=cmd_info)

    # Feedback command
    p = subparsers.add_parser('feedback', help='Submit feedback for an app')
    p.add_argument('app', help='App ID/slug')
    p.add_argument('-m', '--message', required=True, help='Feedback message')
    p.add_argument('-t', '--title', help='Feedback title')
    p.add_argument('--type', choices=['bug', 'suggestion', 'rebuild_request'],
                   default='bug', help='Feedback type')
    p.add_argument('-p', '--priority', choices=['low', 'medium', 'high'],
                   default='medium', help='Priority level')
    p.add_argument('--attach-logs', action='store_true',
                   help='Attach app logs to feedback')
    p.set_defaults(func=cmd_feedback)

    # Logs command
    p = subparsers.add_parser('logs', help='View app logs')
    p.add_argument('app', help='App ID')
    p.add_argument('-n', '--lines', type=int, default=50, help='Number of lines')
    p.add_argument('-a', '--all', action='store_true', help='Include rotated logs')
    p.add_argument('-l', '--list', action='store_true', help='List log files')
    p.add_argument('--clear', action='store_true', help='Clear all logs for app')
    p.set_defaults(func=cmd_logs)

    # Subscribe command
    p = subparsers.add_parser('subscribe', help='Subscribe to app updates')
    p.add_argument('app', help='App ID/slug')
    p.set_defaults(func=cmd_subscribe)

    # Unsubscribe command
    p = subparsers.add_parser('unsubscribe', help='Unsubscribe from app updates')
    p.add_argument('app', help='App ID/slug')
    p.set_defaults(func=cmd_unsubscribe)

    # Subscriptions command
    subparsers.add_parser('subscriptions', help='List subscribed apps').set_defaults(func=cmd_subscriptions)

    # Check updates command
    subparsers.add_parser('check-updates', help='Check for updates to subscribed apps').set_defaults(func=cmd_check_updates)

    args = parser.parse_args()
    if not args.command:
        parser.print_help()
        return 0

    return args.func(args)

if __name__ == '__main__':
    sys.exit(main())
