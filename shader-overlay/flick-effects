#!/usr/bin/env python3
"""
Flick Effects Overlay for Phosh

Creates a transparent overlay layer that renders GPU shader effects:
- Touch ripples (water, snow, CRT, ASCII)
- Living pixels (stars, fireflies, dust, shimmer)

Uses GTK Layer Shell to create an overlay on top of phosh.
"""

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('Gdk', '3.0')
gi.require_version('GtkLayerShell', '0.1')

from gi.repository import Gtk, Gdk, GLib, GtkLayerShell
import cairo
import math
import time
import json
import os
from dataclasses import dataclass
from typing import List, Optional, Dict
import random
import threading
import shutil
import subprocess

# Try to import evdev for touch monitoring
try:
    import evdev
    from evdev import ecodes
    EVDEV_AVAILABLE = True
except ImportError:
    EVDEV_AVAILABLE = False
    print("Warning: python3-evdev not available, touch effects disabled")

# Framebuffer for screen sampling
import mmap
import struct

class ScreenReader:
    """Read screen pixels using grim (Wayland screenshot tool)"""
    def __init__(self):
        self.width = 720
        self.height = 1600
        self.background_data = None  # Cached background for living pixels
        self.last_bg_capture = 0
        self.touch_region_data = {}  # Cached regions for fisheye: slot -> (cx, cy, data, w, h)
        self._check_grim()

    def _check_grim(self):
        self.grim_available = shutil.which('grim') is not None
        if self.grim_available:
            print("Screen reader: using grim")
        else:
            print("Screen reader: grim not available")

    def capture_background(self):
        """Capture full screen for background brightness (called periodically)"""
        if not self.grim_available:
            return
        try:
            # Capture at lower resolution for speed
            result = subprocess.run(
                ['grim', '-t', 'ppm', '-s', '0.25', '-'],
                capture_output=True, timeout=1
            )
            if result.returncode == 0:
                self.background_data = self._parse_ppm(result.stdout)
                self.last_bg_capture = time.time()
        except:
            pass

    def capture_touch_region(self, slot, cx, cy, radius):
        """Capture region around touch point for fisheye"""
        if not self.grim_available:
            return
        try:
            r = int(radius)
            x = max(0, int(cx) - r)
            y = max(0, int(cy) - r)
            w = min(r * 2, self.width - x)
            h = min(r * 2, self.height - y)

            result = subprocess.run(
                ['grim', '-g', f'{x},{y} {w}x{h}', '-t', 'ppm', '-'],
                capture_output=True, timeout=0.5
            )
            if result.returncode == 0:
                data, pw, ph = self._parse_ppm(result.stdout)
                if data:
                    self.touch_region_data[slot] = (cx, cy, data, pw, ph, x, y)
        except:
            pass

    def clear_touch_region(self, slot):
        """Clear cached touch region"""
        if slot in self.touch_region_data:
            del self.touch_region_data[slot]

    def _parse_ppm(self, data):
        """Parse PPM image data, return (pixels, width, height)"""
        try:
            # PPM format: P6\nwidth height\nmaxval\n<binary RGB>
            header_end = 0
            newlines = 0
            for i, b in enumerate(data):
                if b == ord('\n'):
                    newlines += 1
                    if newlines == 3:
                        header_end = i + 1
                        break

            header = data[:header_end].decode('ascii')
            lines = header.strip().split('\n')
            w, h = map(int, lines[1].split())
            pixels = data[header_end:]
            return (pixels, w, h)
        except:
            return (None, 0, 0)

    def get_brightness(self, x, y):
        """Get brightness at screen position (from cached background)"""
        if not self.background_data or not self.background_data[0]:
            return 0.5  # Default to medium if no capture

        pixels, w, h = self.background_data
        # Scale coordinates (background is 0.25 scale)
        sx, sy = int(x * 0.25), int(y * 0.25)
        if sx < 0 or sy < 0 or sx >= w or sy >= h:
            return 0.5

        offset = (sy * w + sx) * 3
        if offset + 3 > len(pixels):
            return 0.5

        r, g, b = pixels[offset], pixels[offset+1], pixels[offset+2]
        return (0.299 * r + 0.587 * g + 0.114 * b) / 255.0

    def get_touch_pixel(self, slot, dx, dy):
        """Get pixel from cached touch region"""
        if slot not in self.touch_region_data:
            return None
        cx, cy, pixels, w, h, ox, oy = self.touch_region_data[slot]
        # dx, dy are offsets from center
        px = w // 2 + int(dx)
        py = h // 2 + int(dy)
        if px < 0 or py < 0 or px >= w or py >= h:
            return None
        offset = (py * w + px) * 3
        if offset + 3 > len(pixels):
            return None
        return (pixels[offset], pixels[offset+1], pixels[offset+2])

    def close(self):
        pass

# Configuration
CONFIG_PATH = os.path.expanduser("~/.local/state/flick/effects_config.json")
DEFAULT_CONFIG = {
    "touch_effect_style": 0,  # 0=water, 1=snow, 2=crt, 3=terminal
    "fisheye_size": 0.16,
    "fisheye_strength": 0.13,
    "ripple_size": 0.30,
    "ripple_strength": 0.07,
    "ripple_duration": 0.5,
    "living_pixels": False,
    "lp_stars": True,
    "lp_shooting_stars": True,
    "lp_fireflies": True,
    "lp_dust": True,
    "lp_shimmer": True,
    "rain_effect_enabled": False,
}


@dataclass
class TouchEffect:
    """A single touch effect (ripple)"""
    x: float
    y: float
    start_time: float
    is_ripple: bool = False

    def age(self) -> float:
        return time.time() - self.start_time

    def is_expired(self, duration: float) -> bool:
        if self.is_ripple:
            return self.age() > duration
        return False


@dataclass
class LivingPixel:
    """A living pixel effect (star, firefly, etc.)"""
    x: float
    y: float
    pixel_type: str  # 'star', 'firefly', 'dust', 'shooting_star'
    start_time: float
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    brightness: float = 1.0
    size: float = 2.0

    def age(self) -> float:
        return time.time() - self.start_time


class EffectsOverlay(Gtk.Window):
    """Transparent overlay for shader effects"""

    def __init__(self):
        super().__init__(title="Flick Effects")

        self.config = self.load_config()
        self.touches: List[TouchEffect] = []
        self.living_pixels: List[LivingPixel] = []
        self.last_spawn_time = 0
        self.screen_width = 1080  # Will be updated
        self.screen_height = 2340
        self.active_touches: Dict[int, tuple] = {}  # slot -> (x, y)
        self.touch_monitor_thread = None
        self.running = True
        self.screen_reader = ScreenReader()

        # Set up transparent window
        self.set_app_paintable(True)
        screen = self.get_screen()
        visual = screen.get_rgba_visual()
        if visual:
            self.set_visual(visual)

        # Set up layer shell
        GtkLayerShell.init_for_window(self)
        GtkLayerShell.set_layer(self, GtkLayerShell.Layer.OVERLAY)
        GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.TOP, True)
        GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.BOTTOM, True)
        GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.LEFT, True)
        GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.RIGHT, True)
        GtkLayerShell.set_exclusive_zone(self, -1)  # Don't reserve space
        GtkLayerShell.set_keyboard_mode(self, GtkLayerShell.KeyboardMode.NONE)

        # Make input pass through
        self.set_accept_focus(False)
        self.set_can_focus(False)

        # Drawing area
        self.drawing_area = Gtk.DrawingArea()
        self.drawing_area.connect('draw', self.on_draw)
        self.add(self.drawing_area)

        # Touch event handling via separate input region
        self.add_events(Gdk.EventMask.TOUCH_MASK |
                       Gdk.EventMask.BUTTON_PRESS_MASK |
                       Gdk.EventMask.BUTTON_RELEASE_MASK)
        self.connect('touch-event', self.on_touch)
        self.connect('button-press-event', self.on_button_press)
        self.connect('button-release-event', self.on_button_release)

        # Animation timer (60 FPS)
        GLib.timeout_add(16, self.on_tick)

        # Config reload timer
        GLib.timeout_add(3000, self.reload_config)

        # Make window click-through
        self.realize()
        self.input_shape_combine_region(cairo.Region())

        self.show_all()

        # Start evdev touch monitoring
        if EVDEV_AVAILABLE:
            self.start_touch_monitor()

    def load_config(self) -> dict:
        """Load effects configuration"""
        try:
            with open(CONFIG_PATH) as f:
                config = json.load(f)
                return {**DEFAULT_CONFIG, **config}
        except:
            return DEFAULT_CONFIG.copy()

    def reload_config(self) -> bool:
        """Reload config periodically"""
        self.config = self.load_config()
        return True

    def find_touchscreen(self):
        """Find the touchscreen input device"""
        for path in evdev.list_devices():
            try:
                dev = evdev.InputDevice(path)
                caps = dev.capabilities()
                # Look for multitouch absolute axes
                if ecodes.EV_ABS in caps:
                    abs_caps = caps[ecodes.EV_ABS]
                    has_mt_x = any(c[0] == ecodes.ABS_MT_POSITION_X for c in abs_caps)
                    has_mt_y = any(c[0] == ecodes.ABS_MT_POSITION_Y for c in abs_caps)
                    if has_mt_x and has_mt_y:
                        return dev, abs_caps
            except:
                pass
        return None, None

    def start_touch_monitor(self):
        """Start the touch monitoring thread"""
        dev, abs_caps = self.find_touchscreen()
        if not dev:
            print("No touchscreen found")
            return

        # Get touch coordinate ranges
        self.touch_max_x = 1080
        self.touch_max_y = 2340
        for code, info in abs_caps:
            if code == ecodes.ABS_MT_POSITION_X:
                self.touch_max_x = info.max
            elif code == ecodes.ABS_MT_POSITION_Y:
                self.touch_max_y = info.max

        print(f"Touch device: {dev.name}")
        print(f"Touch range: {self.touch_max_x}x{self.touch_max_y}")

        self.touch_monitor_thread = threading.Thread(
            target=self.touch_monitor_loop,
            args=(dev,),
            daemon=True
        )
        self.touch_monitor_thread.start()

    def touch_monitor_loop(self, dev):
        """Monitor touch events from evdev"""
        current_slot = 0
        slot_x = {}
        slot_y = {}
        slot_tracking = {}

        try:
            for event in dev.read_loop():
                if not self.running:
                    break

                if event.type == ecodes.EV_ABS:
                    if event.code == ecodes.ABS_MT_SLOT:
                        current_slot = event.value
                    elif event.code == ecodes.ABS_MT_TRACKING_ID:
                        if event.value == -1:
                            # Touch ended
                            if current_slot in slot_tracking:
                                x = slot_x.get(current_slot, 0)
                                y = slot_y.get(current_slot, 0)
                                # Scale to screen coordinates
                                alloc = self.get_allocation()
                                sx = (x / self.touch_max_x) * alloc.width
                                sy = (y / self.touch_max_y) * alloc.height
                                GLib.idle_add(self.on_evdev_touch_end, current_slot, sx, sy)
                                del slot_tracking[current_slot]
                        else:
                            # Touch started
                            slot_tracking[current_slot] = event.value
                    elif event.code == ecodes.ABS_MT_POSITION_X:
                        slot_x[current_slot] = event.value
                        # Update position while dragging
                        if current_slot in slot_tracking:
                            alloc = self.get_allocation()
                            sx = (slot_x[current_slot] / self.touch_max_x) * alloc.width
                            sy = (slot_y.get(current_slot, 0) / self.touch_max_y) * alloc.height
                            GLib.idle_add(self.on_evdev_touch_move, current_slot, sx, sy)
                    elif event.code == ecodes.ABS_MT_POSITION_Y:
                        slot_y[current_slot] = event.value
                        # Update position while dragging
                        if current_slot in slot_tracking:
                            alloc = self.get_allocation()
                            sx = (slot_x.get(current_slot, 0) / self.touch_max_x) * alloc.width
                            sy = (slot_y[current_slot] / self.touch_max_y) * alloc.height
                            GLib.idle_add(self.on_evdev_touch_move, current_slot, sx, sy)

                elif event.type == ecodes.EV_SYN and event.code == ecodes.SYN_REPORT:
                    # Sync event - check for new touches
                    for slot, tracking_id in slot_tracking.items():
                        if slot not in self.active_touches:
                            x = slot_x.get(slot, 0)
                            y = slot_y.get(slot, 0)
                            alloc = self.get_allocation()
                            sx = (x / self.touch_max_x) * alloc.width
                            sy = (y / self.touch_max_y) * alloc.height
                            GLib.idle_add(self.on_evdev_touch_start, slot, sx, sy)
        except Exception as e:
            print(f"Touch monitor error: {e}")

    def on_evdev_touch_start(self, slot, x, y):
        """Handle touch start from evdev (called in main thread)"""
        self.active_touches[slot] = (x, y)
        self.add_touch(x, y)
        # Capture region for fisheye distortion
        alloc = self.get_allocation()
        radius = min(alloc.width, alloc.height) * self.config.get('fisheye_size', 0.16)
        self.screen_reader.capture_touch_region(slot, x, y, radius)
        return False

    def on_evdev_touch_move(self, slot, x, y):
        """Handle touch move from evdev (called in main thread)"""
        self.active_touches[slot] = (x, y)
        # Update the active touch position
        for touch in self.touches:
            if not touch.is_ripple:
                touch.x = x
                touch.y = y
                break
        return False

    def on_evdev_touch_end(self, slot, x, y):
        """Handle touch end from evdev (called in main thread)"""
        if slot in self.active_touches:
            del self.active_touches[slot]
        self.screen_reader.clear_touch_region(slot)
        self.end_touch(x, y)
        return False

    def on_touch(self, widget, event):
        """Handle touch events"""
        if event.touch.type == Gdk.EventType.TOUCH_BEGIN:
            self.add_touch(event.touch.x, event.touch.y)
        elif event.touch.type == Gdk.EventType.TOUCH_END:
            self.end_touch(event.touch.x, event.touch.y)
        return False  # Let event pass through

    def on_button_press(self, widget, event):
        """Handle mouse press (for testing)"""
        self.add_touch(event.x, event.y)
        return False

    def on_button_release(self, widget, event):
        """Handle mouse release"""
        self.end_touch(event.x, event.y)
        return False

    def add_touch(self, x: float, y: float):
        """Add a new touch effect"""
        self.touches.append(TouchEffect(x=x, y=y, start_time=time.time()))

    def end_touch(self, x: float, y: float):
        """Convert touch to ripple"""
        # Find closest active touch and convert to ripple
        for touch in self.touches:
            if not touch.is_ripple:
                touch.is_ripple = True
                touch.start_time = time.time()
                touch.x = x
                touch.y = y
                break

    def spawn_living_pixels(self, width: int, height: int):
        """Spawn living pixel effects"""
        if not self.config.get('living_pixels'):
            return

        now = time.time()
        if now - self.last_spawn_time < 0.1:  # Spawn every 100ms
            return
        self.last_spawn_time = now

        # Random chance to spawn different effects
        # Stars only appear on dark backgrounds
        if self.config.get('lp_stars') and random.random() < 0.4:
            x = random.random() * width
            y = random.random() * height * 0.6  # Upper portion
            # Check if background is dark enough for stars
            bg_brightness = self.screen_reader.get_brightness(x, y)
            if bg_brightness < 0.3:  # Only on dark areas
                self.living_pixels.append(LivingPixel(
                    x=x,
                    y=y,
                    pixel_type='star',
                    start_time=now,
                    brightness=random.random(),
                    size=random.uniform(1, 3)
                ))

        if self.config.get('lp_shooting_stars') and random.random() < 0.01:
            x = random.random() * width
            y = random.random() * height * 0.3
            bg_brightness = self.screen_reader.get_brightness(x, y)
            if bg_brightness < 0.4:  # Only on darker areas
                self.living_pixels.append(LivingPixel(
                    x=x,
                    y=y,
                    pixel_type='shooting_star',
                    start_time=now,
                    velocity_x=random.uniform(200, 400),
                    velocity_y=random.uniform(100, 200),
                    size=2
                ))

        if self.config.get('lp_fireflies') and random.random() < 0.05:
            x = random.random() * width
            y = height * 0.5 + random.random() * height * 0.5
            bg_brightness = self.screen_reader.get_brightness(x, y)
            if bg_brightness < 0.5:  # Fireflies prefer darker areas
                self.living_pixels.append(LivingPixel(
                    x=x,
                    y=y,
                    pixel_type='firefly',
                    start_time=now,
                    velocity_x=random.uniform(-20, 20),
                    velocity_y=random.uniform(-10, 10),
                    size=random.uniform(2, 4)
                ))

        if self.config.get('lp_dust') and random.random() < 0.08:
            self.living_pixels.append(LivingPixel(
                x=random.random() * width,
                y=random.random() * height,
                pixel_type='dust',
                start_time=now,
                velocity_x=random.uniform(-5, 5),
                velocity_y=random.uniform(5, 15),
                brightness=random.uniform(0.3, 0.7),
                size=random.uniform(1, 2)
            ))

        if self.config.get('lp_shimmer') and random.random() < 0.02:
            self.living_pixels.append(LivingPixel(
                x=random.random() * width,
                y=random.random() * height,
                pixel_type='shimmer',
                start_time=now,
                brightness=random.random(),
                size=random.uniform(3, 6)
            ))

    def on_tick(self) -> bool:
        """Animation tick"""
        # Clean up expired effects
        duration = self.config.get('ripple_duration', 0.5)
        self.touches = [t for t in self.touches if not t.is_expired(duration)]

        # Clean up old living pixels (stars last longer)
        self.living_pixels = [p for p in self.living_pixels
                              if (p.pixel_type == 'star' and p.age() < 15.0) or
                                 (p.pixel_type != 'star' and p.age() < 5.0)]

        # Periodic background capture for living pixels (every 2 seconds)
        now = time.time()
        if now - self.screen_reader.last_bg_capture > 2.0:
            self.screen_reader.capture_background()

        # Spawn new living pixels
        alloc = self.get_allocation()
        self.spawn_living_pixels(alloc.width, alloc.height)

        # Trigger redraw
        self.drawing_area.queue_draw()
        return True

    def on_draw(self, widget, cr):
        """Draw effects"""
        alloc = widget.get_allocation()
        width, height = alloc.width, alloc.height

        # Clear with transparent
        cr.set_operator(cairo.OPERATOR_SOURCE)
        cr.set_source_rgba(0, 0, 0, 0)
        cr.paint()

        cr.set_operator(cairo.OPERATOR_OVER)

        # Draw ripple effects
        style = self.config.get('touch_effect_style', 0)
        for touch in self.touches:
            if touch.is_ripple:
                self.draw_ripple(cr, touch, width, height, style)
            else:
                self.draw_fisheye_indicator(cr, touch, width, height)

        # Draw living pixels
        self.draw_living_pixels(cr, width, height)

        return False

    def draw_ripple(self, cr, touch: TouchEffect, width: int, height: int, style: int):
        """Draw a ripple effect"""
        age = touch.age()
        duration = self.config.get('ripple_duration', 0.5)
        progress = min(age / duration, 1.0)

        # Ease out
        eased = 1.0 - (1.0 - progress) ** 3

        max_radius = min(width, height) * self.config.get('ripple_size', 0.3)
        radius = max_radius * eased

        # Fade out
        alpha = (1.0 - progress) ** 2 * 0.6

        if style == 0:  # Water
            # Outer ring
            cr.set_source_rgba(0.3, 0.6, 1.0, alpha * 0.5)
            cr.set_line_width(3)
            cr.arc(touch.x, touch.y, radius, 0, 2 * math.pi)
            cr.stroke()

            # Inner ring
            cr.set_source_rgba(0.5, 0.8, 1.0, alpha)
            cr.set_line_width(2)
            cr.arc(touch.x, touch.y, radius * 0.7, 0, 2 * math.pi)
            cr.stroke()

        elif style == 1:  # Snow
            # Snowflake pattern
            cr.set_source_rgba(1.0, 1.0, 1.0, alpha)
            for i in range(6):
                angle = i * math.pi / 3
                x1 = touch.x + math.cos(angle) * radius * 0.3
                y1 = touch.y + math.sin(angle) * radius * 0.3
                x2 = touch.x + math.cos(angle) * radius
                y2 = touch.y + math.sin(angle) * radius
                cr.move_to(x1, y1)
                cr.line_to(x2, y2)
            cr.set_line_width(2)
            cr.stroke()

        elif style == 2:  # CRT
            # Scanline effect
            cr.set_source_rgba(0.0, 1.0, 0.3, alpha * 0.3)
            for y in range(int(touch.y - radius), int(touch.y + radius), 4):
                if 0 <= y < height:
                    dx = math.sqrt(max(0, radius**2 - (y - touch.y)**2))
                    cr.rectangle(touch.x - dx, y, dx * 2, 2)
            cr.fill()

        elif style == 3:  # Terminal/ASCII
            # Terminal-style expanding ring with characters
            cr.select_font_face("monospace", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            cr.set_font_size(12)
            chars = "01#@*+."
            char_spacing = 14
            num_chars = int(2 * math.pi * radius / char_spacing)

            for i in range(num_chars):
                angle = (i / num_chars) * 2 * math.pi
                x = touch.x + math.cos(angle) * radius
                y = touch.y + math.sin(angle) * radius
                char = chars[i % len(chars)]

                cr.set_source_rgba(0.0, 1.0, 0.0, alpha)
                cr.move_to(x - 4, y + 4)
                cr.show_text(char)

    def draw_fisheye_indicator(self, cr, touch: TouchEffect, width: int, height: int):
        """Draw fisheye distortion using captured screen region"""
        radius = min(width, height) * self.config.get('fisheye_size', 0.16)
        strength = self.config.get('fisheye_strength', 0.13)

        # Pulsing effect
        pulse = 0.8 + 0.2 * math.sin(touch.age() * 4)

        cx, cy = touch.x, touch.y
        r_int = int(radius)

        # Find which slot this touch belongs to (use slot 0 as default)
        slot = 0
        for s, (tx, ty) in self.active_touches.items():
            if abs(tx - cx) < 10 and abs(ty - cy) < 10:
                slot = s
                break

        # Draw distorted pixels from captured region
        has_pixels = slot in self.screen_reader.touch_region_data
        if has_pixels:
            step = 3  # Sample every 3 pixels for performance
            for dy in range(-r_int, r_int + 1, step):
                for dx in range(-r_int, r_int + 1, step):
                    dist = math.sqrt(dx*dx + dy*dy)
                    if dist > radius:
                        continue

                    # Fisheye distortion formula
                    norm_dist = dist / radius
                    if norm_dist > 0:
                        # Barrel distortion - pull pixels inward
                        distorted_dist = norm_dist * (1 + strength * norm_dist * norm_dist)
                        scale = distorted_dist / norm_dist
                    else:
                        scale = 1

                    # Source offset (where to sample from in captured region)
                    src_dx = int(dx * scale)
                    src_dy = int(dy * scale)

                    # Get pixel color from captured region
                    pixel = self.screen_reader.get_touch_pixel(slot, src_dx, src_dy)
                    if pixel:
                        r, g, b = pixel
                        # Draw at destination
                        dest_x = cx + dx
                        dest_y = cy + dy

                        # Fade at edges
                        edge_fade = 1.0 - (norm_dist ** 2)

                        cr.set_source_rgba(r/255, g/255, b/255, edge_fade * 0.95)
                        cr.rectangle(dest_x, dest_y, step, step)
                        cr.fill()

        # Outer glow ring
        gradient = cairo.RadialGradient(cx, cy, radius * 0.85, cx, cy, radius)
        gradient.add_color_stop_rgba(0, 0.3, 0.7, 1.0, 0.0)
        gradient.add_color_stop_rgba(0.5, 0.3, 0.7, 1.0, 0.4 * pulse)
        gradient.add_color_stop_rgba(1, 0.2, 0.5, 0.8, 0.0)
        cr.set_source(gradient)
        cr.arc(cx, cy, radius, 0, 2 * math.pi)
        cr.fill()

        # Subtle crosshair
        cr.set_source_rgba(1.0, 1.0, 1.0, 0.3 * pulse)
        cr.set_line_width(1)
        line_len = radius * 0.1
        cr.move_to(cx - line_len, cy)
        cr.line_to(cx + line_len, cy)
        cr.move_to(cx, cy - line_len)
        cr.line_to(cx, cy + line_len)
        cr.stroke()

    def draw_living_pixels(self, cr, width: int, height: int):
        """Draw living pixel effects"""
        now = time.time()

        for pixel in self.living_pixels:
            age = pixel.age()

            # Update position for moving pixels
            if pixel.pixel_type in ('shooting_star', 'firefly', 'dust'):
                pixel.x += pixel.velocity_x * 0.016  # 60 FPS
                pixel.y += pixel.velocity_y * 0.016

            if pixel.pixel_type == 'star':
                # Twinkling star
                twinkle = 0.5 + 0.5 * math.sin(age * 5 + pixel.brightness * 10)
                alpha = twinkle * 0.8
                cr.set_source_rgba(1.0, 1.0, 0.9, alpha)
                cr.arc(pixel.x, pixel.y, pixel.size, 0, 2 * math.pi)
                cr.fill()

            elif pixel.pixel_type == 'shooting_star':
                # Shooting star with trail
                alpha = max(0, 1.0 - age * 0.5)
                for i in range(5):
                    trail_alpha = alpha * (1 - i * 0.2)
                    trail_x = pixel.x - pixel.velocity_x * 0.016 * i * 2
                    trail_y = pixel.y - pixel.velocity_y * 0.016 * i * 2
                    cr.set_source_rgba(1.0, 1.0, 0.8, trail_alpha)
                    cr.arc(trail_x, trail_y, pixel.size * (1 - i * 0.15), 0, 2 * math.pi)
                    cr.fill()

            elif pixel.pixel_type == 'firefly':
                # Glowing firefly
                glow = 0.5 + 0.5 * math.sin(age * 3)
                alpha = glow * 0.9 * max(0, 1 - age * 0.2)

                # Glow
                gradient = cairo.RadialGradient(pixel.x, pixel.y, 0, pixel.x, pixel.y, pixel.size * 3)
                gradient.add_color_stop_rgba(0, 0.8, 1.0, 0.3, alpha)
                gradient.add_color_stop_rgba(1, 0.5, 0.8, 0.2, 0)
                cr.set_source(gradient)
                cr.arc(pixel.x, pixel.y, pixel.size * 3, 0, 2 * math.pi)
                cr.fill()

                # Core
                cr.set_source_rgba(1.0, 1.0, 0.5, alpha)
                cr.arc(pixel.x, pixel.y, pixel.size, 0, 2 * math.pi)
                cr.fill()

            elif pixel.pixel_type == 'dust':
                # Floating dust particle
                alpha = pixel.brightness * max(0, 1 - age * 0.25)
                cr.set_source_rgba(0.9, 0.85, 0.75, alpha * 0.6)
                cr.arc(pixel.x, pixel.y, pixel.size, 0, 2 * math.pi)
                cr.fill()

            elif pixel.pixel_type == 'shimmer':
                # Sparkling shimmer effect
                sparkle = abs(math.sin(age * 8 + pixel.brightness * 20))
                alpha = sparkle * max(0, 1 - age * 0.3)

                if sparkle > 0.7:
                    # Draw cross sparkle
                    cr.set_source_rgba(1.0, 1.0, 1.0, alpha)
                    cr.set_line_width(1)
                    # Horizontal line
                    cr.move_to(pixel.x - pixel.size, pixel.y)
                    cr.line_to(pixel.x + pixel.size, pixel.y)
                    # Vertical line
                    cr.move_to(pixel.x, pixel.y - pixel.size)
                    cr.line_to(pixel.x, pixel.y + pixel.size)
                    cr.stroke()

                    # Center dot
                    cr.arc(pixel.x, pixel.y, 1.5, 0, 2 * math.pi)
                    cr.fill()


def main():
    """Main entry point"""
    # Check if running on Wayland
    if not os.environ.get('WAYLAND_DISPLAY'):
        print("Error: Flick Effects requires Wayland")
        return 1

    print("Starting Flick Effects overlay...")

    overlay = EffectsOverlay()

    def on_destroy(widget):
        widget.running = False
        Gtk.main_quit()

    overlay.connect('destroy', on_destroy)

    try:
        Gtk.main()
    except KeyboardInterrupt:
        pass

    return 0


if __name__ == '__main__':
    exit(main())
